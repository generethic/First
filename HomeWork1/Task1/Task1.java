package HomeWork1.Task1;

public class Task1 {
    public static void main(String[] args) {
        int a = 42; //00101010

        int b = 15; //00001111
        System.out.println();

        System.out.println(a|b); // побитовый OR  : если  хотя бы один из битов равен 1, то результирующий 1. На выходе: 00101111,или 47
        System.out.println(a&b); // побитовый AND : если оба биты равны 1, то результирующий 1. На выходе: 00001010, или 10
        System.out.println(a^b); // побитовый XOR : если 1 бит равен 0, а второй 1, то результирующий 1. На выходе: 00100101, или 37
        System.out.println(a>>b); //смещение на 15 единиц вправо. На выходе 0
        System.out.println(a<<b); //смещение на 15 единиц влево. На выходе 1376256 или (00000000000101010000000000000000)
        System.out.println(a>>>b); //смещение на 15 единиц вправо. На выходе 0
        System.out.println(~a); //побитовое NOT. На выходе 11010101,или -43, т.к. инвертируется как n==-(n+1) при переводе
        System.out.println(~b); //побитовок NOT. На выходе 11110000,или -16, т.к. инвертируется как n==-(n+1) при переводе
        System.out.println("-------");
        a &= b;
        a |= b;
        a ^= b;
        a >>= b;
        a <<= b;
        a >>>= b;

        int c = -42; //11111111111111111111111111010110
        int d = -15; //11111111111111111111111111110001
        System.out.println(Integer.toBinaryString(-5505024));
        System.out.println(c|d); //11111111111111111111111111110111. В данном случае получается надо считать по нулям, т.к. первый бит 1:индекс 3(от начала). -(2^3+1)=-9
        System.out.println(c&d); //11111111111111111111111111010000. В данном случае получается надо считать по нулям, т.к первый бит 1:_-(2^0+2^1+2^2+2^3+2^5+1)=-47
        System.out.println(c^d); //00000000000000000000000000100111. В данном случае получается надо считать по единицам, т.к. первый бит 0:(1+2+4+32)=39
        System.out.println(c>>d);//первый бит не сдвигается (отвечает за знак). Получается 11111111111111111111111111111111 -> 1.
        System.out.println(c<<d);//первый бит не сдвигается (отвечает за знак).
        System.out.println(c>>>d);//происходит сдвиг на 15 единиц вправо вместе со знаком, получается 00000000000000000111111111111111 ->32767
        System.out.println(~c); //побитовое NOT. На выходе  41, т.к. инвертируется как n==-(n+1) при переводе
        System.out.println(~d); //побитовое NOT. На выходе  14, т.к. инвертируется как n==-(n+1) при переводе
        System.out.println("-------");
        c &= d; //
        c |= d; //
        c ^= d; //
        c >>= d; //
        c <<= d; //
        c >>>= d; //

    }
}
